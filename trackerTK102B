#!/usr/bin/php -q
<?php
###################################################################
# tracker is developped with GPL Licence 2.0
#
# GPL License: http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt
#
# Developped by : Cyril Feraudet
#
# 2017-03-12 Modified for TK-102B by Kari Karvonen <oh1kk at toimii.fi>
#
###################################################################
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
#    For information : cyril@feraudet.com
####################################################################
/**
  * Database creation script
  * CREATE DATABASE `tracker` DEFAULT CHARACTER SET utf8
  * USE `tracker`;
  * CREATE TABLE IF NOT EXISTS `tracker` (
  *   `id` int(11) NOT NULL AUTO_INCREMENT,
  *   `imei` varchar(12) NOT NULL,
  *   `timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  *   `satelliteFixStatus` char(1) NOT NULL,
  *   `latitude` DECIMAL(10, 8) NOT NULL,
  *   `longitude` DECIMAL(11, 8) NOT NULL,
  *   `speed` float NOT NULL,
  *   `orientation` varchar(6) NOT NULL,
  *   `iostate` varchar(8) NOT NULL,
  *   `miledata` varchar(8) NOT NULL,
  *   `rawstring` varchar(82) DEFAULT NULL,
  *   PRIMARY KEY (`id`),
  *   KEY `imei` (`imei`)
  * ) ENGINE=MyISAM  DEFAULT CHARSET=utf8;
  */

/**
  * Listens for requests and forks on each connection
  */

$ip = '0.0.0.0';
$port = 65432;

$__server_listening = true;

error_reporting(E_ALL);
set_time_limit(0);
ob_implicit_flush();
declare(ticks = 1);
$debug = false;

if(!isset($argv[1]) || $argv[1] != '-f') {
	become_daemon();
} else {
	$debug = true;
}

/* nobody/nogroup, change to your host's uid/gid of the non-priv user */
change_identity(65534, 65534);

/* handle signals */
pcntl_signal(SIGTERM, 'sig_handler');
pcntl_signal(SIGINT, 'sig_handler');
pcntl_signal(SIGCHLD, 'sig_handler');

/* change this to your own host / port */
server_loop($ip, $port);

/**
  * Change the identity to a non-priv user
  */
function change_identity( $uid, $gid )
{
    if( !posix_setgid( $gid ) )
    {
        print "Unable to setgid to " . $gid . "!\n";
	print "Hint: try running as root\n";
        exit;
    }

    if( !posix_setuid( $uid ) )
    {
        print "Unable to setuid to " . $uid . "!\n";
        exit;
    }
}

/**
  * Creates a server socket and listens for incoming client connections
  * @param string $address The address to listen on
  * @param int $port The port to listen on
  */
function server_loop($address, $port)
{
    GLOBAL $__server_listening;

    if(($sock = socket_create(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        echo "failed to create socket: ".socket_strerror($sock)."\n";
        exit();
    }

    if (!socket_set_option($sock, SOL_SOCKET, SO_REUSEADDR, 1)) 
    {
         echo "Unable to set option on socket: ". socket_strerror(socket_last_error()) . PHP_EOL;
    }

    if(($ret = socket_bind($sock, $address, $port)) < 0)
    {
        echo "failed to bind socket: ".socket_strerror($ret)."\n";
        exit();
    }

    if( ( $ret = socket_listen( $sock, 0 ) ) < 0 )
    {
        echo "failed to listen to socket: ".socket_strerror($ret)."\n";
        exit();
    }

    socket_set_nonblock($sock);
   
    echo "waiting for clients to connect\n";

    while ($__server_listening)
    {
        $connection = @socket_accept($sock);
        if ($connection === false)
        {
            usleep(100);
        }elseif ($connection > 0)
        {
            handle_client($sock, $connection);
        }else
        {
            echo "error: ".socket_strerror($connection);
            die;
        }
    }
}

/**
  * Signal handler
  */
function sig_handler($sig)
{
    switch($sig)
    {
        case SIGTERM:
        case SIGINT:

            exit();
        break;

        case SIGCHLD:
            pcntl_waitpid(-1, $status);
        break;
    }
}

/**
  * Handle a new client connection
  */
function handle_client($ssock, $csock)
{
    GLOBAL $__server_listening;

    $pid = pcntl_fork();

    if ($pid == -1)
    {
        /* fork failed */
        echo "fork failure!\n";
        die;
    }elseif ($pid == 0)
    {
        /* child process */
        $__server_listening = false;
        socket_close($ssock);
        interact($csock);
        socket_close($csock);
    }else
    {
        socket_close($csock);
    }
}

function interact($socket)
{
	global $debug;
    	/* TALK TO YOUR CLIENT */
	$rec = "";
	$unknown_message = true;
	$client_address="";
	$client_port="";
	socket_recv($socket, $rec, 2048, 0);
	socket_getpeername($socket, $client_address, $client_port);
	debug_print("Connection from $client_address:$client_port");

	$regex1="/";
	$regex1.="(?<IMEI>.{12})";
	$regex1.="(?<CMD>.{4})";
	$regex1.="(?<GPSDATE>\d{6})";
	$regex1.="(?<VALID>[VA])";
	$regex1.="(?<LATITUDE1>\d{2})(?<LATITUDE2>\d{2}\.\d{4})(?<LATITUDE3>N|S)";
	$regex1.="(?<LONGITUDE1>\d{3})(?<LONGITUDE2>\d{2}\.\d{4})(?<LONGITUDE3>E|W)";
	$regex1.="(?<SPEED>\d{3}\.\d{1})";
	$regex1.="(?<GPSTIME>\d{6})";
	$regex1.="(?<ORIENTATION>.{6}),";
	$regex1.="(?<IOSTATE>\d{8})";
	$regex1.="L";
        $regex1.="(?<MILEDATA>\d{8})";
	$regex1.="/";

	if (preg_match($regex1, $rec, $out)) {
		debug_print("Received coordinates: ".$out["0"]);
	        $lat = $out["LATITUDE1"]+$out["LATITUDE2"]/60;
	        $lon = $out["LONGITUDE1"]+$out["LONGITUDE2"]/60;
	        if ($out["LATITUDE3"] == "S") $lat=-1*$lat;
	        if ($out["LONGITUDE3"] == "W") $lon=-1*$lon;
	        date_default_timezone_set("UTC");
	        $timestamp = strtotime("20".$out["GPSDATE"]." ".$out["GPSTIME"]);
		$dbconn = mysqli_connect('localhost', 'tracker', 'tracker','tracker');
		$query = "INSERT INTO tracker (imei, timestamp, satelliteFixStatus, latitude, longitude, speed, orientation, iostate, miledata, rawstring) VALUES (?,from_unixtime(?),?,?,?,?,?,?,?,?)";
		if ($stmt = mysqli_prepare ($dbconn , $query)) {
			mysqli_stmt_bind_param($stmt,"sisdddssss", $out["IMEI"], $timestamp, $out["VALID"], $lat, $lon, $out["SPEED"], $out["ORIENTATION"], $out["IOSTATE"], $out["MILEDATA"], $rec);
			mysqli_stmt_execute($stmt);
			if (mysqli_stmt_errno($stmt) <> 0) printf("Error: %d. %s\n", mysqli_stmt_errno($stmt), mysqli_stmt_error($stmt));
			mysqli_stmt_close($stmt);
		}
		mysqli_close($dbconn);
		$unknown_message=false;
	}
	if (preg_match("/(?<IMEI>.{12})BP00HSO/",$rec,$out)) {
		// Handshake. No coodrinates.
		debug_print("Received Up message: ".$out["0"]);
		//$answer="(".$out["IMEI"]."AP01HSO)";
		//debug_print("Sending handshake answer: ".$answer);
		//socket_send($socket,$answer,strlen($answer),MSG_EOR);
		$unknown_message = false;

	}
	if ($unknown_message) {
		debug_print("Received unknown message: $rec");
	}
}

/**
  * Become a daemon by forking and closing the parent
  */
function become_daemon()
{
    $pid = pcntl_fork();
   
    if ($pid == -1)
    {
        /* fork failed */
        echo "fork failure!\n";
        exit();
    }elseif ($pid)
    {
        /* close the parent */
        exit();
    }else
    {
        /* child becomes our daemon */
        posix_setsid();
        chdir('/');
        umask(0);
        return posix_getpid();

    }
} 

function debug_print($msg) {
	global $debug;
	if ($debug) echo date("d.m.Y H:i:s")." $msg\n";
}


?>
